# -*- coding: utf-8 -*-
"""REF_logged_cyclingThreshold.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pthmlNmCUDMSfLHLNDNPZDA6oVfngsae
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from matplotlib.colors import LogNorm
from matplotlib.ticker import ScalarFormatter

# Parameters
r = 2  # growth rate
c = 1  # normal death
beta = 0.02  # infection
gamma = 0.1  # extra death from infection
b = 0.3  # phage death
n = 5  # burst size (disease growth?)
k = 1000  # cc of susceptible
muout = 0  # sus entering population from refuge
muin = 0  # sus leaving population into refuge
alpha = 0.3  # death in refuge
m = 1000  # cc of refuge population ################

# Initial conditions
N0 = (np.log(10), np.log(10), np.log(10), np.log(1))

# Model
def model(t,N,r,c,beta,gamma,b,n,k,muin, muout, alpha, m):
    S=N[0]
    I=N[1]
    P=N[2]
    R=N[3]
    dS = r*(1-np.exp(S)/k)-c-beta*np.exp(P)-muin+muout*np.exp(R-S)
    dI = beta*np.exp(S+P-I)- c- gamma
    dP = gamma*n*np.exp(I-P) - b
    dR = r*(1-np.exp(R)/m)+muin*np.exp(S-R)-alpha-muout
    return np.array([dS,dI, dP, dR])


# Time points to use
tc = np.linspace(100, 500, 5001)

# Solving and running the model
sol = solve_ivp(model, [tc[0],tc[-1]], N0, t_eval=tc, args=(r,c,beta,gamma,b,n,k,muin, muout, alpha, m),method='Radau')

# Create a meshgrid of muin and muout values
muin_range = np.arange(0, 10.1, 0.1)
muout_range = np.arange(0, 10.1, 0.1)
muin_mesh, muout_mesh = np.meshgrid(muin_range, muout_range)

cycling_results = np.zeros((101, 101))

for i, muin in enumerate(muin_range):
    for j, muout in enumerate(muout_range):
        print(f'Testing combination: muin={muin}, muout={muout}')
        sol = solve_ivp(model, [tc[0], tc[-1]], N0, t_eval=tc,
                        args=(r, c, beta, gamma, b, n, k, muin, muout, alpha, m))
        P = sol.y[2]
        if max(np.exp(P[-1000:])) - min(np.exp(P[-1000:])) > 10:
            cycling_results[i, j] = max(np.exp(P[-1000:])) - min(np.exp(P[-1000:]))

# Calculating the default amplitude
default_amplitude = cycling_results[0, 0]
print(default_amplitude)

# Calculate relative amplitudes
relative_amplitudes = cycling_results / default_amplitude

print(default_amplitude)
print(relative_amplitudes)

max_value = np.max(cycling_results)

fig, ax= plt.subplots(figsize=(8,6))

levels = np.linspace(0, max_value, 50)

contour = plt.contourf(muout_mesh.T ,muin_mesh.T, cycling_results, levels=levels, cmap='viridis')

plt.xlabel ('muout')
plt.ylabel('muin')

plt.gca().xaxis.set_major_formatter(ScalarFormatter())
plt.gca().yaxis.set_major_formatter(ScalarFormatter())

plt.xlim(0, 10)
plt.ylim(0, 10)

cbar = plt.colorbar(contour)
cbar.set_label('')

vmin = 0  # Minimum value for color scale
vmax = 2000  # Maximum value for color scale

# Set the color scale explicitly
levels = np.linspace(vmin, vmax, 50)
contour = plt.contourf(muout_mesh, muin_mesh, cycling_results, levels=levels, cmap='coolwarm', vmin=vmin, vmax=vmax)

plt.xlabel('muout')
plt.ylabel('muin')

plt.gca().xaxis.set_major_formatter(ScalarFormatter())
plt.gca().yaxis.set_major_formatter(ScalarFormatter())

plt.xlim(0, 10)
plt.ylim(0, 10)

# Create a color bar
cbar = plt.colorbar(contour)
cbar.set_label('')

plt.show()